# 실습을 위한 개발 환경 세팅
* https://github.com/slipp/web-application-server 프로젝트를 자신의 계정으로 Fork한다. Github 우측 상단의 Fork 버튼을 클릭하면 자신의 계정으로 Fork된다.
* Fork한 프로젝트를 eclipse 또는 터미널에서 clone 한다.
* Fork한 프로젝트를 eclipse로 import한 후에 Maven 빌드 도구를 활용해 eclipse 프로젝트로 변환한다.(mvn eclipse:clean eclipse:eclipse)
* 빌드가 성공하면 반드시 refresh(fn + f5)를 실행해야 한다.

# 웹 서버 시작 및 테스트
* webserver.WebServer 는 사용자의 요청을 받아 RequestHandler에 작업을 위임하는 클래스이다.
* 사용자 요청에 대한 모든 처리는 RequestHandler 클래스의 run() 메서드가 담당한다.
* WebServer를 실행한 후 브라우저에서 http://localhost:8080으로 접속해 "Hello World" 메시지가 출력되는지 확인한다.

# 각 요구사항별 학습 내용 정리
* 구현 단계에서는 각 요구사항을 구현하는데 집중한다. 
* 구현을 완료한 후 구현 과정에서 새롭게 알게된 내용, 궁금한 내용을 기록한다.
* 각 요구사항을 구현하는 것이 중요한 것이 아니라 구현 과정을 통해 학습한 내용을 인식하는 것이 배움에 중요하다. 

### 요구사항 1 - http://localhost:8080/index.html로 접속시 응답
* socket의 inputstream으로부터 request의 요청을 읽어온다. 
  그런데, 필요한 헤더 값마다 파싱해서 사용하는 것이 불편하다고 느꼈다. 다른 프레임 워크에서는 각각의 헤더에 대한 값을 하드 코딩해서 파싱을 하는 코드가 있는 것인지 궁금해졌다.
  
* view인 index.html을 리턴할 때 파일을 읽어 응답을 준다. 이때 자바 코드단에서 응답을 적절히 수정해서 동적인 요청을 처리할 수 있겠다고 생각이 들었다.
### 요구사항 2 - get 방식으로 회원가입
* 컨트롤러에서 어떻게 url별 분기를 효율적으로 처리할 수 있을지 고민된다. if문으로 url별 분기를 처리하는 편이 좋을까? 그렇다면,
url별 메서드를 별도로 구분하는 것이 좋을까? 고민이된다.

### 요구사항 3 - post 방식으로 회원가입
* -

### 요구사항 4 - redirect 방식으로 이동
* http status code의 종류가 많은데 이것을 요청받은 request handler에서 책임을 지는 것이 아니라
각각의 url별 컨트롤러에서 설정을 해주는게 맞지 않을 까 싶다. 이걸 어떻게 책 후반부에서 리팩토링하는지 궁금하다.

### 요구사항 5 - cookie
* 요구 사항 4에서 고민했던 부분을 어느정도 해소했다. 각 route되는 컨트롤러 별로
응답 헤더 설정의 책임을 지니게하고 기존에 RequsetHandler 클래스에서만 집중된 응답 관련
  로직을 분산해줬다. 하지만 url경로 별로 분기하여 처리하는데 이렇게 하드코딩하지 말고
   더 편하게 할 수 있는 방법이 무엇인지 궁금하다.

### 요구사항 6 - stylesheet 적용
* 응답에 대한 header의 종류가 점차 다양해졌다. 처음에는 메서드에서 content-type, http 상태코드등이 결합되서
응답 헤더를 만들어 주다가 쿠기의 등장으로 하나씩 헤더를 분리하기 시작했고 content-type도 분리해서 css를 적용했다. 메서드는
  최대한 작게, 하나의 책임을 지녀야한다는 말이 다시금 생각났다.

### 첫번째 리팩토링 시도
* 책에서 준 몇가지 키워드와 클래스 구조의 힌트를 보고 코드를 리팩토링 해봤다.
1. if/else if 구분으로 url을 분기 처리하던 것을 controller 인터페이스를 활용하여 if/eles if분기가 아닌 클래스로 확장할 수 있도록
리팩토링 하였다. 새로운 request path에 대해 OCP를 유지할 수 있는 방법이었다. 또, 추상 골격 클래스를 활용하여 중복된 코드를 지우면서 
   지원하지 않는 http method에 대해 예외를 던질 수 있는 default를 로직을 작성하였다.
   

2. request, response에 대한 책임을 아예 클래스 단위로 분리했다. 이전에는 클래스 단위로 분리하기 보단 유틸 클래스를 만들어서
필요한 메서드만 작성하고 처리했다. 하지만 클래스를 분리하고 이 클래스를 사용하여 각 컨트롤러와 통신하는 방식이
   획일화되는 느낌을 받았다. 만약, 분리하지 않았다면 컨트롤러마다 필요한 파라미터가 달라 유지보수가 어려운
   구조가 되었을 것 같다. 캡슐화의 장점을 얻을 수 있었다.
   

3. 점점 구현하면서 느끼는건데 servlet을 밑바닥부터 구현하는 느낌이 강하게 든다.


4. url마다 클래스를 구현하면서 OCP를 지킬 수 있지만, 코드가 많아질 수록 파악하기 복잡해질 것 같다는 느낌이 든다.
   spring mvc에 dispatcher servlet동작 코드를 보고싶다.
   