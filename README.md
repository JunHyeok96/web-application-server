# 실습을 위한 개발 환경 세팅
* https://github.com/slipp/web-application-server 프로젝트를 자신의 계정으로 Fork한다. Github 우측 상단의 Fork 버튼을 클릭하면 자신의 계정으로 Fork된다.
* Fork한 프로젝트를 eclipse 또는 터미널에서 clone 한다.
* Fork한 프로젝트를 eclipse로 import한 후에 Maven 빌드 도구를 활용해 eclipse 프로젝트로 변환한다.(mvn eclipse:clean eclipse:eclipse)
* 빌드가 성공하면 반드시 refresh(fn + f5)를 실행해야 한다.

# 웹 서버 시작 및 테스트
* webserver.WebServer 는 사용자의 요청을 받아 RequestHandler에 작업을 위임하는 클래스이다.
* 사용자 요청에 대한 모든 처리는 RequestHandler 클래스의 run() 메서드가 담당한다.
* WebServer를 실행한 후 브라우저에서 http://localhost:8080으로 접속해 "Hello World" 메시지가 출력되는지 확인한다.

# 각 요구사항별 학습 내용 정리
* 구현 단계에서는 각 요구사항을 구현하는데 집중한다. 
* 구현을 완료한 후 구현 과정에서 새롭게 알게된 내용, 궁금한 내용을 기록한다.
* 각 요구사항을 구현하는 것이 중요한 것이 아니라 구현 과정을 통해 학습한 내용을 인식하는 것이 배움에 중요하다. 

### 요구사항 1 - http://localhost:8080/index.html로 접속시 응답
* socket의 inputstream으로부터 request의 요청을 읽어온다. 
  그런데, 필요한 헤더 값마다 파싱해서 사용하는 것이 불편하다고 느꼈다. 다른 프레임 워크에서는 각각의 헤더에 대한 값을 하드 코딩해서 파싱을 하는 코드가 있는 것인지 궁금해졌다.
  
* view인 index.html을 리턴할 때 파일을 읽어 응답을 준다. 이때 자바 코드단에서 응답을 적절히 수정해서 동적인 요청을 처리할 수 있겠다고 생각이 들었다.
### 요구사항 2 - get 방식으로 회원가입
* 컨트롤러에서 어떻게 url별 분기를 효율적으로 처리할 수 있을지 고민된다. if문으로 url별 분기를 처리하는 편이 좋을까? 그렇다면,
url별 메서드를 별도로 구분하는 것이 좋을까? 고민이된다.

### 요구사항 3 - post 방식으로 회원가입
* -

### 요구사항 4 - redirect 방식으로 이동
* http status code의 종류가 많은데 이것을 요청받은 request handler에서 책임을 지는 것이 아니라
각각의 url별 컨트롤러에서 설정을 해주는게 맞지 않을 까 싶다. 이걸 어떻게 책 후반부에서 리팩토링하는지 궁금하다.

### 요구사항 5 - cookie
* 요구 사항 4에서 고민했던 부분을 어느정도 해소했다. 각 route되는 컨트롤러 별로
응답 헤더 설정의 책임을 지니게하고 기존에 RequsetHandler 클래스에서만 집중된 응답 관련
  로직을 분산해줬다. 하지만 url경로 별로 분기하여 처리하는데 이렇게 하드코딩하지 말고
   더 편하게 할 수 있는 방법이 무엇인지 궁금하다.

### 요구사항 6 - stylesheet 적용
* 응답에 대한 header의 종류가 점차 다양해졌다. 처음에는 메서드에서 content-type, http 상태코드등이 결합되서
응답 헤더를 만들어 주다가 쿠키의 등장으로 하나씩 헤더를 분리하기 시작했고 content-type도 분리해서 css를 적용했다. 메서드는
  최대한 작게, 하나의 책임을 지녀야한다는 말이 다시금 생각났다.

### 리팩토링 시도
* 책에서 준 몇가지 키워드와 클래스 구조의 힌트를 보고 코드를 리팩토링 해봤다.
1. if/else if 구분으로 url을 분기 처리하던 것을 controller 인터페이스를 활용하여 if/eles if분기가 아닌 클래스로 확장할 수 있도록
리팩토링 하였다. 새로운 request path에 대해 OCP를 유지할 수 있는 방법이었다. 또, 추상 골격 클래스를 활용하여 중복된 코드를 지우면서 
   지원하지 않는 http method에 대해 예외를 던질 수 있는 default를 로직을 작성하였다.
   

2. request, response에 대한 책임을 아예 클래스 단위로 분리했다. 이전에는 클래스 단위로 분리하기 보단 유틸 클래스를 만들어서
필요한 메서드만 작성하고 처리했다. 하지만 클래스를 분리하고 이 클래스를 사용하여 각 컨트롤러와 통신하는 방식이
   획일화되는 느낌을 받았다. 만약, 분리하지 않았다면 컨트롤러마다 필요한 파라미터가 달라 유지보수가 어려운
   구조가 되었을 것 같다. 캡슐화의 장점을 얻을 수 있었다.
   

3. 리팩토링을 하다보니 servlet을 밑바닥부터 구현하는 것 같다.
   
### 책의 리팩토링 내용과 나의 리팩토링 과정 비교
1. 책에서는 HttpMethod를 enum을 사용해 리팩토링했다. 나도 enum을 활용해 status, method, header등을 정의했다. 
아무래도 String형태보다 enum을 사용하는 것이 타입의 안정성, 비슷한 성격을 가진 상수간 집합등 좀 더 코드가 직관적이고 오류를 줄어주는 방향으로 판단된다.


2. 책에서는 RequsetMapping객체를 별도로 사용하여 url을 매핑했다. 나는 별도의 클래스를 분리하지 않고 RequestHandler에서 url별 controller를 저장하는 메서드를
만들었는데 책의 내용대로 별도의 객체로 분리하는 편이 하나의 클래스에서 더 명확한 책임을 지닐 수 있게하고 가독성 또한 높아지는 것 같다. 
   

3. login확인을 컨트롤러에서 쿠키를 꺼내 확인하는 방식을 사용했는데, 책에서는 HttpRequset내부에서 login여부를 확인하는 메서드를 만들 것을 추천했다.
요청 객체에서 충분히 처리할 수 있고 코드의 중복을 줄일 수 있다는 점에서 수용하였다.
   
4. static block을 사용하는 형태는 처음봤는데, 클래스를 초기화할 때 사용할 수 있었다. static block은 클래스가 로딩될 떄 초기화, 인스턴스 block은 인스턴스가 생성될 때 초기화

5. controller + abstract class로 추상 골격 클래스를 만들 때 책에서는 doGet, doPost메서드에 아무런 로직을 구성하지 않았다. 하지만, 제공하지 않은 method방식이 호출되면 예외를 던지는 편이 
낫다고 생각했고 오버라이딩하지 않으면 예외를 던지도록 하였다.

### 정리
1. 메서드/클래스는 최대한 작게! 하나의 책임을 지닐 수록 재사용성이 커진다.
2. 인터페이스를 활용해서 OCP를 어떻게 지켜내는지 확인했다. if/else if분기가 늘어나는 것을 다형성으로 처리할 수 있다.
3. 여러개의 값을 반환하며 처리하는 private 메서드를 테스트하는 방법은 package private이외에도 별도의 클래스로 분리하여 테스트 할 수있는 방법도 있다.
4. Http 응답 메시지를 만들때 response에서 오류가 발생한 적이 있는데, 메시지의 순서를 상태 라인보다 응답 헤더를 먼저 설정한 문제였다. 
5. 객체에서 값을 꺼내서 사용하기보단 객체에 메시지를 보내자.